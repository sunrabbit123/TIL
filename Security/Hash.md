# 해시 함수

## 일방향 해시함수
### 특징
1. 임의 길이의 메시지로부터 고정 길이의 해시값을 계산한다.
2. 해시값을 고속으로 계산 가능하다.
3. 일방향성을 갖는다.
4. 메시지가 다르면 해시값도 다르다.
5. 일반적으로 해시함수는 다대일 대응 함수이다. 이는 충돌이 반드시 존재함을 뜻한다.
    - 따라서 충돌내성을 가질 필요가 있다.

### 요구사항
`프리이미지 저항성`, `제2프리이미지 저항성`, `충돌 저항성`
일방향 해시함수는 이 세가지가 충족이 되어야만한다.

> 프리이미지
> f(x)=y에서 x는 y의 이전 이미지라고 한다.
> f가 일대일 대응이 아니라면, 하나의 y에 여러 개의 이전 이미지가 있을 수 있다.

#### 프리이미지 저항성
역상저항성이라고도 불린다.

- 암호학적 해시함수는 프리이미지 저항성이 있어야 한다.
- 프리이미지 저항성이란 주어진 해시함수 h와 y=h(M)에 있어 Eve가 y=h(M)을 만족하는 메시지 M'를 찾아낸다는 것이 매우 힘들어야 한다는 성질이다.

#### 제2프리이미지 저항성
두번째 역상 저항성, 약한 충돌 내성이라고도 불린다.

이는 메시지를 쉽게 위조할 수 없도록 하는 성질이다.

1. Eve는 메시지 M과 다이제스트 h(M)을 가로챈다.
2. Eve는 h(M)=h(M')을 만족하는 다른 메시지 (M')을 생성한다.
3. Eve는 M'과 h(M')을 Bob에게 보낸다.
Eve는 이렇게 해서 메시지를 위조 할 수 있다.

이런 충돌이 발생할 확률은 충돌저항성보다 상대적으로 낮기 때문에 약한 충돌 내성이라고 한다.

#### 충돌 저항성
충돌 회피성, 강한 충돌 내성이라고도 불린다.

이는 Eve로 하여금 동일한 다이제스트를 가지는 2개의 메시지를 구하지 못하도록 하는 것이다.
여기서 공격자는 어떤 정보도 없는 상태에서 동일한 다이제스트를 갖는 두 개의 메시지를 생성할 수 있다.

> 충돌이 발생할 확률이 약한 충돌 내성보다 상대적으로 높기에, 강한 충돌 내성이라고 한다.


##### 암호학적 해시함수의 요구사항
|요구사항|설명|
|:----:|:-:|
|다양한 입력 길이|H는 어떤 크기의 데이터 블록에도 적용될 수 있다.|
|고정된 출력 길이|H는 고정된 크기의 출력을 만든다.|
|효율성|H(x)는 실질적으로 하드웨어 및 소프트웨어에 적용하기 용이하여야 하며, 어떠한 x에 대해서도 계산이 비교적 수월해야 한다.
|선이미지 회피성(일 방향성)|어떠한 코드 h에 대해서도 H(x)=h인 x를 찾는 것은 계산적으로 불가능해야 한다.|
|2차 선이미지 회피성(약한 충돌 회피성)|어떠한 블록 x에 대해서도, H(y)=H(x)인 y(!=x)인 것을 찾는 것이 계산적으로 실행 불가능하다.|
|충돌 회피성(강한 충돌 회피성)|H(x)=H(y)인 어떤 (x, y)짝을 찾는 것이 계산적으로 실행 불가능하다.|

## 키가 없는 해시함수, 키가 있는 해시함수

### 반복 해시함수
모든 암호학적 해시함수는 입력되는 메시지의 크기와 상관없이 항상 출력의 크기가 일정해야한다.
이런 함수를 만드는 가장 좋은 방법은 반복을 사용하는 것이다.
입력의 길이가 다양한 해시함수 대신에 고정 길이의 입력을 필요로 하는 함수를 만들고, 필요한 만큼 반복을 하는 것이다.

#### Merkle-Damgard의 구조
이 구조는 현재 사용되고 있는 많은 해시함수 구조의 기본 틀이다.
우리가 할 한가지의 일은 충돌 내성을 갖는 압축함수를 설계하여
이 구조안에 넣는 것이다.

### 키가 없는 해시함수
해시함수는 내부 압축 함수들로 구성된 연산의 성질에 의해 다음과 같이 세 부분으로 나눌 수 있따.
- 블록 암호를 기초로 한 해시함수
- 전용 해시함수(처음부터 새로 만드는 것)
- 모듈 연산을 기초로 한 해시함수

오늘날 사용되고 있는 전용 해시함수인 `SHA-1`, `RIPEMD`, `RIPEMD-128`, `RIPEMD-160`, `HAVAL`등은 모두 MD4를 기초로 하였다.

#### Message Digest(MD2 -> MD4 -> MD5)
MD 알고리즘은 RSA를 개발한 미국 MIT의 Rivest교수가 공개키 기반 구조를 만들기 위해 RSA와 함께 개발했다.
최종 버전인 MD5는 메시지를 512비트로 된 블럭들로 나누고, 128비트 다이제스트를 출력한다.

- 현재 128비트 메시지 다이제스트는 충돌 공격에 내성을 갖기엔 너무 짧다.
- MD5는 내부 구조에 대한 몇가지 약점이 발견되고, 2005년에 강한 충돌 공격 내성을 공격하는 `Birthday Attack`에 노출되어 보안이 필요할 경우 추천되고 있지는 않다.

#### SHA(Secure Hash Algorithm)
현재 가장 널리 사용되는 SHA는 DSS(Digital Signature Standard)에 사용하기 위해 NSA가 설계하여 NIST에 의해서 배포되었다.

2002년에 NIST는 새로운 표준인 FIPS 180-2를 내놓았는데, 이때 해시값이 각각 256, 384, 512비트인 새로운 SHA버전을 정의했따.
각각 `SHA-256`, `SHA-284`, `SHA-512`이다.
이들을 통칭하여 `SHA-2`라고 한다.

`SHA-2`는 `SHA-1`과 하부구조가 같으며, 동일한 유형의 모듈러 연산과 논리적 2진연산을 이용하고 있다.
2008년에 수정된 문서가 FIP PUB 180-3으로 출판되었는데 여기에는 224-비트 버전이 추가되었다.

2005년에 SHA-1의 강한 충돌 내성이 깨졌따는 것을 접수하고 NIST는 SHA-1을 대신하여 SHA-3을 제정하기로 하였다.
SHA-3(Keccak)는 AES와 같은 방식으로 표준화 되었다.

#### RIPEMD-160
RIPEMD(Race Itegrity Primitives Evaluation Message Digest)도 여러 개의 버전으로 되어있따.
RIPEMD-160은 160bit 메시지 다이제스트를 생성하는 해시 알고리즘이다.

이는 유럽 RIPE 프로젝트로 만들어진 RIPMD라는 일방향 해시함수의 개정판이다.
RIPEMD의 강한 충돌 내성은 2004년에 깨졌지만, RIPEMD-160은 아직 깨지지 않았다.
> RIPEMD-160은 비트코인에서 사용되고 있다.

#### Tiger
ROss Anderson과 Biham이 1995년에 타이거라 불리는 해시 함수를 갭라하였다.
TIger은 64비트 시스템에서 해시 함수를 구현하기 위해 설계되었고, MD5, Sha-1보다 더 속도가 빠르다.

#### HAVAL
HAVAL은 길이가 128, 160, 192, 224 및 256bit인 Message Digest를 출력하는 가변 길이 해시 알고리즘이고, 사용되는 블록의 크기는 1024bit이다.

### 키를 사용하는 해시함수
키를 사용하는 해시함수는 메시지 인증 기능을 가진 함수이다.
일반적인 해싱함수와는 달리 키를 사용하는 해시함수는 함수 자체의 안전성과 키의 비밀성에 그 안전성을 두고 있다.

#### 블록 암호 기반 메시지 인증 알고리즘
블록 암호에 기반을 둔 메시지 인증 알고리즘 중 가장 널리 사용되는 방법은 CBC모드를이용하는 방법이다.
ex : DES를 CBC모드에서 사용하여 해시함수를 만드는 방법으로 여기서의 키의 비트는 DES에서 사용되는 56비트이다.

### 블록암호 기반 해시함수
반복 암호학적 해시함수 안에 사용되는 압축함수 자리에 대칭키 블록암호를 사용할수도 있다.
그러면 일부러 새로운 압축함수를 만들 필요 없이 DES나 AES처럼 검증된 여러 개의 대칭키 알고리즘을 일방향 함수로 사용할 수 있기 대문이다.
이 경우에는 블록암호의 암호화 기능만 사용한다.

### 모듈 연산에 기반을 둔 해시함수
모듈 연산에 기반을 둔 해시함수는 압축 함수의 기반을 모듈 연산의 반복적인 수행에 두고 있는 해시함수를 말한다.

이 함수는 하드웨어나 소프트웨어 자체에 내장된 모듈 연산을 사용할 수 있다는 장점이 있으나 속도가 빠르지 않고 안전성 연구에 대한 역사가 짧다는 단점이 있다.

### 암호학적 해시함수의 응용
1. 무결성 점검
    메시지 혹은 문서의 무결성을 점검하기 위해 암호학적 해시함수를 비교해 보아야 한다.
    이렇게 생서된 메시지 다이제스트와 이전의 메시지다이제스트를 비교하여
    두개가 동일하다면 원래의 메시지가 변경되지 않았다는 것을 알 수 있다.

2. 소프트웨어 변경 검출
    자신이 입수한 소프트웨어가 변경되었는지를 확인하기 위해 일방향 해시함수가 사용되는 경우가 있다.
    사용자는 소프트웨어를 입수한 후, 자신의 손으로 해시값을 다시 계산해서 그것을 사이트에서 제공하는 해시값과 비교한다.

3. 메시지 인증코드
    일반적으로, 메시지 인증은 키가 있는 해시 함수로 알려진 메시지 인증 코드를 사용하여 얻어진다.
    전형적으로 MAC(Message Authentication Code, 메시지 인증 코드)는 상호 간에 교환되는 정보를 인증하기 위해, 비밀키를 공유하는 두 통신 상대자 간에 사용된다.
    이는 SSL/TLS에서도 사용된다.

4. 전자서명
    전자서명을 할 때 일방향 해시함수가 사용된다.
    전자서명이란 현실 사회의 서명이나 날인에 해당하는 행위를 디지털 세계로 가져온 것이다.

### 랜덤 오라클 모델과 해시함수에 대한 공격
#### 랜덤 오라클 모델
Bellare와 Rogaway가 1993년에 소개한 랜덤 오라클 모델은 해시함수에 대한 이상적인 수학적 모델이다.

이 모델에 근거한 해시함수는 다음과 같은 성질을 갖는다.
- 임의의 길이를 갖는 메세지에 오라클은 0과 1로 이루어진 난수 스트링인 고정된 길이의 Message digest를 생성해서 제공한다.
- 새로운 메세지에 대한 digest는 다른 모든 digest와는 독립적으로 선택될 필요가 있다. 이는 오라클이 digest를 만들기 위해 공식이나 알고리즘을 사용해서는 안된다는 것을 의미한다.

##### 비둘기집 원리
이 원리는 만약 n+1마리의 비둘기가 n개의 비둘기집에 들어가있다면 적어도 한 비둘기집에는 두 마리의 비둘기가 있다는 뜻이다.

일반화된 비둘기집 원리 버전은, 만약 kn + 1마리의 비둘기가 n개의 비둘기집에 들어가야한다면, 적어도 한 비둘기집에는 k+1마리의 비둘기가 들어가야있어야 한다는 원리이다.

이는 해시값에도 한계가 있고, 그 한계만큼 값을 집어넣는다면, 하나 이상은 충돌이 난다는 소리이다.

##### 생일 공격
특정한 해시값을 생성하는 메시지를 구하는게 아닌, 해시값은 괜찮으니 같은 해시값을 생성하는 2개의 메시지를 구하는 것이다.

이는 일방향 해시함수의 강한 충돌 내성을 깨고자 하는 공격이다.

- 생일 패러독스

생일퀴즈

    랜덤으로 선택한 N명의 그룹을 생각한다.
    N명 중 적어도 2명의 생일이 일치할 확률이 1/2를 넘기기 위한 N의 값은 최소 몇일까?

정답

    N = 23이다. 즉, 23명만 있으면 확률이 약 0.507297이 되어 정답이다.

계산식 
    
    365-(N-1)=365-N+1이 된다.

##### 각 공격법에 대한 강도
|구성|난이도|
|:----:|:--------:|
|프리이미지 저항성|2^n|
|2차 프리이미지 저항성|2^n|
|충돌 저항성|2^(n/2)|

#### 일방향 해시함수에 대한 공격
##### 무차별 대입 공격
암호에 대해 무차별 공격이 가능했던 것 처럼 일방향 해시함수에도 무차별 공격이 가능하다.
이는 일방향 해시함수의 약한 충돌 내성을 공격하는 것 이다.
해시값이 160비트이니 2^160만 시행하면 원하는 메세지가 발견 가능하다.

##### 기타 해시함수 공격의 종류 및 특성
1. 일치블록 연쇄공격
    - 새로운 메세지 M'을 사전에 다양하게 만들어 놓았다가 공격하고자 하는 메세지 M의 해시함수값 h(M)과 같은 해시함수값을 갖는 것을 골라 사용하는 공격이다.
2. 중간자 연쇄공격
    - 전체 해시값이 아니라 해시 중간의 결과에 대한 충돌쌍을 찾는다. 특정 포인트를 공격 대상으로 한다.
3. 고정점 연쇄공격
    - 메시지 블록과 연쇄변수 쌍을 얻게 되면 연쇄변수가 발생하는 특정한 점에서 임의의 수의 동등한 블록들을 메세지의 중간에 삽입해도 전체 해시값이 변하지 않는다.
4. 차분 연쇄공격
    - 다중 라운드 블록암호의 공격
        - 다중 라운드 블록 암호를 사용하늖 ㅐ시 함수에서, 입력값과 그에 대응하는 출력값 차이의 통계적 특성을 조사하는 기법을 사용한다.
    - 해시함수의 공격
        - 압축함수의 입출력 차이를 조사하여 0의 충돌쌍을 주로 찾아내는 방법을 사용한다.

### 일방향 해시함수로 해결 불가능한 문제
일방향 해시함수는 조작과 변경을 검출할 수 있지만, 거짓행세를 검출하지는 못한다.
파일의 무결성을 조사하는 것뿐만 아니라 이 파일이 정말로 앨리스의 것인가를 확인하고 싶은 경우에는 무결성 외에 인증이라는 절차가 필요해진다.
이 인증을 수행하기 위한 기술이 바로 메시지 인증코드와 전자서명이다.

## 암호학적 해시함수의 예
### SHA-512
SHA-512는 다중-블록 메세지로부터 512bit digest를 생성한다.
각 블록은 1024bit 길이를 가진다.

- 메세지 준비
    SHA-512에서 요구하는 메세지의 길이는 2^128bit를 넘지 않는 것이다.
    만약 메세지의 길이가 2^128bit와 같거나 더 길게 될 경우에 SHA-512가 이 메세지를 처리할 수 없게 된다.
    실상 이 제한이 문제가 되지않는데 그 이유는 2^128비트가 대부분의 컴퓨터 시스템의 저장 용량보다도 크기 때문이다.
    > 미래에는 문제가 되지않을까...

- 길이 필드와 패딩
    Message digest를 생성하기 전에 SHA-512에서는 메세지에 추가적으로 덧붙이는 128bit의 부호 없는 정수 길이 필드가 필요하다.
    이 필드에는 메세지의 길이가 bit수로 표현된 값이 저장된다.
    이 길이는 패딩을 하기전의 원래 메세지 길이를 나타낸다.
    메세지 길이 필드는 공격자가 해시값이 같으면서, 입력 값이 다른 메세지를 찾는 것을 어렵게하는 요소이다.

#### SHA-512의 안전성
현재까지 SHA-512의 약점을 지적한 연구 보고서는 없으며, 동일한 Message digest를 갖는 두 메세지를 찾아야 하는 난이도는 2^256번의 연산을 수행해야 얻을 수 있다.
하지만 SHA-512도 이전의 SHA들과 같은 구조를 가지고 있고, 수학적으로도 동일하게 작동하기때문에 우려가 높다.

SHA-512를 대체할 적절한 알고리즘이 나오면 수년이 걸릴 것이고 그 안에 취약점이 나올 것이 분명해 보이기 때문에,
NSIT는 2007년에 차세대 해시 함수로 사용할 SHA-3를 공모하게 되었다.

### SHA-3
SHA-3는 이론적으로 공격방법이 알려져버린 SHA-1을 대신하여 새로운 표준이 된 일방향 해시 알고리즘이다.
전 세계의 기업이나 암호학자가 SHA-3의 후보 알고리즘을 다수 제안하여 5년간에 걸친 선정 작업 후 2012년에 KECCAK라는 알고리즘이 SHA-3로 결정되었다.

#### 선정과정
AES 때와 같이 SHA-3 선정 과정은 전 세계에 공개되고 암호학자끼리 서로 알고리즘을 평가하였다.
즉, 여기에서도 경쟁방식에 의한 표준화가 진행된 것이다.

#### SHA-3 최종후보와 SHA-3의 결정
2010년에 SHA-3 최종 후보로서 5개의 알고리즘이 선정되었다.
- BLAKE
- Grostl
- JH
- KECCAK
- Skein

2012년에 Guido Bertoni, Joan Daemen, Gilles Van Assche, Michael Peeters가 제안한 KECCAK를 SHA-3로 선정하였다.
Joan Daemen은 대칭 암호 알고리즘 AES의 설계자이기도 하다.

## 메세지 인증코드(MAC)
이는 무결성을 확인하고 메세지에 대한 인증을 하는 기술이며 첫 글자를 따서 MAC라고 부른다.
이를 사용하면 변경과 거짓행세를 검출 가능하다.

메세지 인증코드는 임의 길이의 메세지와 송신자 및 수신자가 공유하는 키라는 2개의 입력을 기초로해서 고정 비트길이의 출력을 계산하는 함수이다.
여기서의 출력을 MAC값이라고 한다.

MAC의 한가지 장점은 블록암호나 해시 함수에 기반을 두기 때문에 전자서명보다 훨씬 빠르다는 것이다.

### 변경 감지 코드(MDC, Modification Detection Code)
변경감지 코드는 메세지의 무결성을 보장하는 Message digest이다.

Bob은 수신한 메세지로부터 새로운 MDC를 생성하여 Alice에게 받은 MDC와 비교한다.
만약 이 값이 동일하다면 해당 메세지는 변경되지 않았다는 뜻이 된다.

### 메시지 인증 코드(MAC)
무결성과 데이터 출원지 인증을 보장하기 위해서는 변경 감지코드(MDC)를 메세지 인증코드(MAC)로 바꿀 필요가 있다.

MDC와 MAC의 차이를 살펴보자

MAC에는 Alice와 Bob사이에 비밀값이 포함된다느 ㄴ것이다.
예를 들면 Eve는 가지고 있지 않은 비밀키가 두 사람 사이의 비밀값이 될 수 있다.

하지만 이는 키 배송문제가 생긴다.
MAC에서는 송신자와 수신자가 키를 공유할 필요가 있다.
이는 대칭키 암호 때의 **키 배송 문제**와 같은 문제가 메시지 인증코드에서도 일어남을 뜻한다.

**구현 사례**
---
1. 축소 MAC
    MAC의 안전성을 높이기 위해서 축소 MAC가 설계되었는데 이 안에서는 해시가 두 단계로 이루어져있다.
    1. 키에 메세지를 이어 붙이고 해시하여 중간 단계의 digest를 생성한다.
    2. 키에 중간단계 digest를 이어 붙이고 최종적인 digest를 생성한다.
    