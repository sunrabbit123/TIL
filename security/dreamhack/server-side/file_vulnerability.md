# File Vulnerability

 웹 어플리케이션에서 글만으로는 전달하기 힘든 내용이나 이미지, 문서등과 같이 특별한 형식을 가진 파일을 공유하기 위해 파일을 업로드하고 다운로드할 수 있는 기능이 존재합니다.

예를 들어 결제에 필요한 서류를 전달하기 위해 문서를 업로드 할 수도 있고, 행사를 소개하기 위한 포스터를 업로드 할 수도 있으며, 이 파일들을 다른 사용자와 공유할 수 있도록 다운로드 기능을 지원합니다.

**"File Vulnerability"**에서는 파일을 업로드/다운로드 하는 기능에서 발생할 수 있는 취약점들과 그로부터 안전하게 구현할 수 있는 방법들에 대해 알아보겠습니다.

* [파일 업로드 취약점](file_vulnerability.md#File-Upload) 서버의 파일 시스템에 사용자가 원하는 경로 또는 파일 명 등으로 업로드가 가능하여 악영향을 미칠 수 있는 파일이 업로드되는 취약점입니다.
* [파일 다운로드 취약점](file_vulnerability.md#File-Download) 서버의 기능 구현 상 의도하지 않은 파일을 다운로드할 수 있는 취약점입니다.

## File-Upload

파일 업로드 기능은 사용자의 파일이 서버의 파일 시스템에 저장되어 처리된다는 이유가 취약점이 됩니다.

사용자가 파일 업로드 시 파일의 내용과 함께 파일의 이름도 서버로 전송됩니다.

이때 서버에서 검증이 없다면 파일 시스템에 원하는 파일을 저장할 수 있습니다.

이 취약점을 통해 서버 파일 시스템에 원하는 파일 경로 또는 파일 명을 업로드할 수 있다면 악의적인 공격자는 웹 어플리케이션 또는 서버의 서비스가 참조하는 파일을 업로드하여 공격할 수 있습니다.

이에 앞서 웹 서버의 CGI라는 개념을 알아야 합니다.

### CGI

Common Gateway Interface 이는 사용자의 요청을 받은 서버가 동적인 페이지를 구성하기 위해 엔진에 요청을 보내고, 엔진이 처리한 결과를 서버에게 반환하는 기능을 말합니다.

예를 들어 웹 서버는 Apache, 웹은 PHP를 사용하는 서버에 사용자가 요청을 보내면 Apache는 요청을 해석하고 사용자가 요청하는 리소스의 확장자가 .php와 같이 php엔진을 사용하기로 설정되어 있는 확장자라면

mod\_php\(CGI\)를 통해 사용자의 요청을 php엔진이 처리 및 실행하도록 합니다.

즉 php,jsp,asp 등과 같이 CGI를 통해 서비스를 하는 형태에서는 확장자를 통해 웹 어플리케이션에 엔진에 요청 여부를 판단합니다.

### 공격 방법

그렇다면 웹 서비스가 동작하는 경로에 사용자가 원하는 파일 내용과 파일 명을 업로드 할 수 있다면

서버가 엔진에 요청하는 확장자를 업로드해, 원하는 코드를 실행할 수 있습니다. 웹 서버가 파일을 실행하는 시기는 사용자의 요청이 들어오면 파일 시스템에서 해당 파일을 찾아 실행합니다.

웹 어플리케이션이 실행하는 코드를 조작할 수 있다면 웹 언어에 내장된 OS명령어 등을 사용할 수 있으며, 해당 서버의 쉘을 웹을 통해 사용하여 **WebShell\(웹쉘\)**이라는 악성코드가 등장하였습니다.

### 예시

```php
<?php
    system("ls");
?>
```

또는

```markup
<Script>alert(1);</script>
```

## File-Download

파일 다운로드 기능을 구현하는 방법은 여러가지지만 취약점이 발생하는 가장 흔한 형태는 사용자가 입력한 파일이름을 검증하지않은채 그대로 다운로드시켜주는 형태입니다.

Path Traversal를 이용하면 다운로드 폴더 상위 경로에 존재하는 시스템 파일, 설정 파일과 같은 중요한 정보를 탈취할 수 있습니다.

```text
http://example.com/download?filename=docs.pdf
```

이게 정상적인 형태라면

```text
http://example.com/download?filename=../../../../etc/passwd
```

처럼 다른 경로에 접근하여 다른 파일을 다운받을 수 있습니다.

이 취약점은 소스콛, 패스워드, 서비스 키, 설정 파일등을 유출하기에 다른 이차적인 공격을 위한 발판으로 쓰일 수 있습니다.

### 해결방안 1

인자에 다운로드 받으려는 파일의 경로나 이름을 넘기지 않는 것이 좋다. 하지만 이름으로 구현해야한다면 상대경로에 쓰이는 `..`, `/`, `\\`를 적절히 필터링해야한다.

### 해결방안 2

데이터베이스에 다운로드 될 파일의 경로와 그에 해당하는 랜덤 키를 생성하여 1대 1로 매칭해서 저장해두고, 해당 랜덤 값이 인자로 넘어왔을 때 데이터베이스에 존재하는 파일인지를 먼저 식별하고 다운로드 하는 것이 안전하다.

예시

```python
@app.route("/download")
def download():
    file_id = request.args.get("file_id", "")     # file_id는 쉽게 유추하지 못하는 랜덤한 값이어야 합니다.
    file_path = find_path_from_database(file_id)  # find_path_from_database 함수는 데이터베이스에서 file_id와 매핑된 파일 경로를 반환하는 개발자가 작성한 함수입니다.
    if file_path is None:
        return "올바르지 않은 파일 아이디입니다."
    return open(file_path, "rb").read()
```

이를 잘못구현하여서 `filename = filename.replaceㄴ("...","")`처럼 키워드를 없애면 안전할 것이라 생각할 수 있지만,

공격자는 `..././file`과 같은 형태로 또다른 `../`를 만드는 형식으로 우회할 수 있습니다.

만약 윈도우면 `../`외에 `..\\`로도 상위 경로에 접근할 수 있기 때문에 둘 다 필터링 하는 것이 필요하다.

